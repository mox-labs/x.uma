# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: xds/type/matcher/v3/cel.proto, xds/type/matcher/v3/regex.proto, xds/type/matcher/v3/string.proto, xds/type/matcher/v3/matcher.proto, xds/type/matcher/v3/domain.proto, xds/type/matcher/v3/http_inputs.proto, xds/type/matcher/v3/ip.proto, xds/type/matcher/v3/range.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import Dict, List

import betterproto

from .xds.core import v3
from .xds.type import v3


@dataclass
class CelMatcher(betterproto.Message):
    """
    Performs a match by evaluating a `Common Expression Language
    <https://github.com/google/cel-spec>`_ (CEL) expression against the
    standardized set of :ref:`HTTP attributes <arch_overview_attributes>`
    specified via ``HttpAttributesCelMatchInput``. .. attention::   The match
    is ``true``, iff the result of the evaluation is a bool AND true.   In all
    other cases, the match is ``false``, including but not limited to: non-bool
    types,   ``false``, ``null``, ``int(1)``, etc.   In case CEL expression
    raises an error, the result of the evaluation is interpreted "no match".
    Refer to :ref:`Unified Matcher API
    <envoy_v3_api_msg_.xds.type.matcher.v3.Matcher>` documentation for usage
    details. [#comment: envoy.matching.matchers.cel_matcher]
    """

    # Either parsed or checked representation of the CEL program.
    expr_match: v3.CelExpression = betterproto.message_field(1)
    # Free-form description of the CEL AST, e.g. the original expression text, to
    # be used for debugging assistance.
    description: str = betterproto.string_field(2)


@dataclass
class RegexMatcher(betterproto.Message):
    """A regex matcher designed for safety when used with untrusted input."""

    # Google's RE2 regex engine.
    google_re2: "RegexMatcherGoogleRE2" = betterproto.message_field(
        1, group="engine_type"
    )
    # The regex match string. The string must be supported by the configured
    # engine.
    regex: str = betterproto.string_field(2)


@dataclass
class RegexMatcherGoogleRE2(betterproto.Message):
    """
    Google's `RE2 <https://github.com/google/re2>`_ regex engine. The regex
    string must adhere to the documented `syntax
    <https://github.com/google/re2/wiki/Syntax>`_. The engine is designed to
    complete execution in linear time as well as limit the amount of memory
    used. Envoy supports program size checking via runtime. The runtime keys
    `re2.max_program_size.error_level` and `re2.max_program_size.warn_level`
    can be set to integers as the maximum program size or complexity that a
    compiled regex can have before an exception is thrown or a warning is
    logged, respectively. `re2.max_program_size.error_level` defaults to 100,
    and `re2.max_program_size.warn_level` has no default if unset (will not
    check/log a warning). Envoy emits two stats for tracking the program size
    of regexes: the histogram `re2.program_size`, which records the program
    size, and the counter `re2.exceeded_warn_level`, which is incremented each
    time the program size exceeds the warn level threshold.
    """

    pass


@dataclass
class StringMatcher(betterproto.Message):
    """Specifies the way to match a string. [#next-free-field: 9]"""

    # The input string must match exactly the string specified here. Examples: *
    # *abc* only matches the value *abc*.
    exact: str = betterproto.string_field(1, group="match_pattern")
    # The input string must have the prefix specified here. Note: empty prefix is
    # not allowed, please use regex instead. Examples: * *abc* matches the value
    # *abc.xyz*
    prefix: str = betterproto.string_field(2, group="match_pattern")
    # The input string must have the suffix specified here. Note: empty prefix is
    # not allowed, please use regex instead. Examples: * *abc* matches the value
    # *xyz.abc*
    suffix: str = betterproto.string_field(3, group="match_pattern")
    # The input string must match the regular expression specified here.
    safe_regex: "RegexMatcher" = betterproto.message_field(5, group="match_pattern")
    # The input string must have the substring specified here. Note: empty
    # contains match is not allowed, please use regex instead. Examples: * *abc*
    # matches the value *xyz.abc.def*
    contains: str = betterproto.string_field(7, group="match_pattern")
    # Use an extension as the matcher type. [#extension-category:
    # envoy.string_matcher]
    custom: v3.TypedExtensionConfig = betterproto.message_field(
        8, group="match_pattern"
    )
    # If true, indicates the exact/prefix/suffix matching should be case
    # insensitive. This has no effect for the safe_regex match. For example, the
    # matcher *data* will match both input string *Data* and *data* if set to
    # true.
    ignore_case: bool = betterproto.bool_field(6)


@dataclass
class ListStringMatcher(betterproto.Message):
    """Specifies a list of ways to match a string."""

    patterns: List["StringMatcher"] = betterproto.message_field(1)


@dataclass
class Matcher(betterproto.Message):
    """
    A matcher, which may traverse a matching tree in order to result in a match
    action. During matching, the tree will be traversed until a match is found,
    or if no match is found the action specified by the most specific
    on_no_match will be evaluated. As an on_no_match might result in another
    matching tree being evaluated, this process might repeat several times
    until the final OnMatch (or no match) is decided.
    """

    # A linear list of matchers to evaluate.
    matcher_list: "MatcherMatcherList" = betterproto.message_field(
        1, group="matcher_type"
    )
    # A match tree to evaluate.
    matcher_tree: "MatcherMatcherTree" = betterproto.message_field(
        2, group="matcher_type"
    )
    # Optional OnMatch to use if no matcher above matched (e.g., if there are no
    # matchers specified above, or if none of the matches specified above
    # succeeded). If no matcher above matched and this field is not populated,
    # the match will be considered unsuccessful.
    on_no_match: "MatcherOnMatch" = betterproto.message_field(3)


@dataclass
class MatcherOnMatch(betterproto.Message):
    """What to do if a match is successful."""

    # Nested matcher to evaluate. If the nested matcher does not match and does
    # not specify on_no_match, then this matcher is considered not to have
    # matched, even if a predicate at this level or above returned true.
    matcher: "Matcher" = betterproto.message_field(1, group="on_match")
    # Protocol-specific action to take.
    action: v3.TypedExtensionConfig = betterproto.message_field(2, group="on_match")
    # If true and the Matcher matches, the action will be taken but the caller
    # will behave as if the Matcher did not match. A subsequent matcher or
    # on_no_match action will be used instead. This field is not supported in all
    # contexts in which the matcher API is used. If this field is set in a
    # context in which it's not supported, the resource will be rejected.
    keep_matching: bool = betterproto.bool_field(3)


@dataclass
class MatcherMatcherList(betterproto.Message):
    """
    A linear list of field matchers. The field matchers are evaluated in order,
    and the first match wins.
    """

    # A list of matchers. First match wins.
    matchers: List["MatcherMatcherListFieldMatcher"] = betterproto.message_field(1)


@dataclass
class MatcherMatcherListPredicate(betterproto.Message):
    """Predicate to determine if a match is successful."""

    # A single predicate to evaluate.
    single_predicate: "MatcherMatcherListPredicateSinglePredicate" = (
        betterproto.message_field(1, group="match_type")
    )
    # A list of predicates to be OR-ed together.
    or_matcher: "MatcherMatcherListPredicatePredicateList" = betterproto.message_field(
        2, group="match_type"
    )
    # A list of predicates to be AND-ed together.
    and_matcher: "MatcherMatcherListPredicatePredicateList" = betterproto.message_field(
        3, group="match_type"
    )
    # The invert of a predicate
    not_matcher: "MatcherMatcherListPredicate" = betterproto.message_field(
        4, group="match_type"
    )


@dataclass
class MatcherMatcherListPredicateSinglePredicate(betterproto.Message):
    """Predicate for a single input field."""

    # Protocol-specific specification of input field to match on. [#extension-
    # category: envoy.matching.common_inputs]
    input: v3.TypedExtensionConfig = betterproto.message_field(1)
    # Built-in string matcher.
    value_match: "StringMatcher" = betterproto.message_field(2, group="matcher")
    # Extension for custom matching logic. [#extension-category:
    # envoy.matching.input_matchers]
    custom_match: v3.TypedExtensionConfig = betterproto.message_field(
        3, group="matcher"
    )


@dataclass
class MatcherMatcherListPredicatePredicateList(betterproto.Message):
    """
    A list of two or more matchers. Used to allow using a list within a oneof.
    """

    predicate: List["MatcherMatcherListPredicate"] = betterproto.message_field(1)


@dataclass
class MatcherMatcherListFieldMatcher(betterproto.Message):
    """An individual matcher."""

    # Determines if the match succeeds.
    predicate: "MatcherMatcherListPredicate" = betterproto.message_field(1)
    # What to do if the match succeeds.
    on_match: "MatcherOnMatch" = betterproto.message_field(2)


@dataclass
class MatcherMatcherTree(betterproto.Message):
    # Protocol-specific specification of input field to match on.
    input: v3.TypedExtensionConfig = betterproto.message_field(1)
    exact_match_map: "MatcherMatcherTreeMatchMap" = betterproto.message_field(
        2, group="tree_type"
    )
    # Longest matching prefix wins.
    prefix_match_map: "MatcherMatcherTreeMatchMap" = betterproto.message_field(
        3, group="tree_type"
    )
    # Extension for custom matching logic.
    custom_match: v3.TypedExtensionConfig = betterproto.message_field(
        4, group="tree_type"
    )


@dataclass
class MatcherMatcherTreeMatchMap(betterproto.Message):
    """
    A map of configured matchers. Used to allow using a map within a oneof.
    """

    map: Dict[str, "MatcherOnMatch"] = betterproto.map_field(
        1, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )


@dataclass
class ServerNameMatcher(betterproto.Message):
    """
    Matches a fully qualified server name against a set of domain names with
    optional wildcards.
    """

    # Match a server name by multiple domain matchers. Each domain, exact or
    # wildcard, must appear at most once across all the domain matchers. The
    # server name will be matched against all wildcard domains starting from the
    # longest suffix, i.e. ``www.example.com`` input will be first matched
    # against ``www.example.com``, then ``*.example.com``, then ``*.com``, then
    # ``*``, until the associated matcher action accepts the input. Note that
    # wildcards must be on a dot border, and values like ``*w.example.com`` are
    # invalid.
    domain_matchers: List["ServerNameMatcherDomainMatcher"] = betterproto.message_field(
        1
    )


@dataclass
class ServerNameMatcherDomainMatcher(betterproto.Message):
    """
    Specifies a set of exact and wildcard domains and a match action. The
    wildcard symbol ``*`` must appear at most once as the left-most part of the
    domain on a dot border. The wildcard matches one or more non-empty domain
    parts.
    """

    # A non-empty set of domain names with optional wildcards, e.g.
    # ``www.example.com``, ``*.com``, or ``*``.
    domains: List[str] = betterproto.string_field(1)
    # Match action to apply when the server name matches any of the domain names
    # in the matcher.
    on_match: "MatcherOnMatch" = betterproto.message_field(2)


@dataclass
class HttpAttributesCelMatchInput(betterproto.Message):
    """
    Specifies that matching should be performed on the set of :ref:`HTTP
    attributes <arch_overview_attributes>`. The attributes will be exposed via
    `Common Expression Language <https://github.com/google/cel-spec>`_ runtime
    to associated CEL matcher. Refer to :ref:`Unified Matcher API
    <envoy_v3_api_msg_.xds.type.matcher.v3.Matcher>` documentation for usage
    details. [#comment: envoy.matching.inputs.cel_data_input]
    """

    pass


@dataclass
class IPMatcher(betterproto.Message):
    """
    Matches a specific IP address against a set of possibly overlapping subnets
    using a trie.
    """

    # Match IP address by CIDR ranges.
    range_matchers: List["IPMatcherIPRangeMatcher"] = betterproto.message_field(1)


@dataclass
class IPMatcherIPRangeMatcher(betterproto.Message):
    """Specifies a list of IP address ranges and a match action."""

    # A non-empty set of CIDR ranges.
    ranges: List[v3.CidrRange] = betterproto.message_field(1)
    # Match action to apply when the IP address is within one of the CIDR ranges.
    on_match: "MatcherOnMatch" = betterproto.message_field(2)
    # Indicates whether this match option should be considered if there is a more
    # specific matcher. Exclusive matchers are not selected whenever a more
    # specific matcher exists (e.g. matcher with a longer prefix) even when the
    # more specific matcher fails its nested match condition. Non-exclusive
    # matchers are considered if the more specific matcher exists but its nested
    # match condition does not entirely match. Non-exclusive matchers are
    # selected in the order of their specificity first (longest prefix first),
    # then the order of declaration next. For example, consider two range
    # matchers: an exclusive matcher *X* on ``0.0.0.0/0`` and a matcher *Y* on
    # ``192.0.0.0/2`` with a nested match condition *Z*. For the input IP
    # ``192.168.0.1`` matcher *Y* is the most specific. If its nested match
    # condition *Z* does not accept the input, then the less specific matcher *X*
    # does not apply either despite the input being within the range, because
    # matcher *X* is exclusive. The opposite is true if matcher *X* is not marked
    # as exclusive. In that case matcher *X* always matches whenever matcher "*Y*
    # rejects the input.
    exclusive: bool = betterproto.bool_field(3)


@dataclass
class Int64RangeMatcher(betterproto.Message):
    """
    Specifies a set of ranges for matching an int64 number and the associated
    match actions.
    """

    # Match a number by a list of number ranges. If multiple ranges contain the
    # input number, then the first action in this list is taken.
    range_matchers: List["Int64RangeMatcherRangeMatcher"] = betterproto.message_field(1)


@dataclass
class Int64RangeMatcherRangeMatcher(betterproto.Message):
    """Specifies a list of number ranges and a match action."""

    # A non-empty set of int64 ranges.
    ranges: List[v3.Int64Range] = betterproto.message_field(1)
    # Match action to apply when the input number is within one of the ranges.
    on_match: "MatcherOnMatch" = betterproto.message_field(2)


@dataclass
class Int32RangeMatcher(betterproto.Message):
    """
    Specifies a set of ranges for matching an int32 number and the associated
    match actions.
    """

    # Match a number by a list of number ranges. If multiple ranges contain the
    # input number, then the first action in this list is taken.
    range_matchers: List["Int32RangeMatcherRangeMatcher"] = betterproto.message_field(1)


@dataclass
class Int32RangeMatcherRangeMatcher(betterproto.Message):
    """Specifies a list of number ranges and a match action."""

    # A non-empty set of int32 ranges.
    ranges: List[v3.Int32Range] = betterproto.message_field(1)
    # Match action to apply when the input number is within one of the ranges.
    on_match: "MatcherOnMatch" = betterproto.message_field(2)


@dataclass
class DoubleRangeMatcher(betterproto.Message):
    """
    Specifies a set of ranges for matching a double number and the associated
    match actions.
    """

    # Match a number by a list of number ranges. If multiple ranges contain the
    # input number, then the first action in this list is taken.
    range_matchers: List["DoubleRangeMatcherRangeMatcher"] = betterproto.message_field(
        1
    )


@dataclass
class DoubleRangeMatcherRangeMatcher(betterproto.Message):
    """Specifies a list of number ranges and a match action."""

    # A non-empty set of double ranges.
    ranges: List[v3.DoubleRange] = betterproto.message_field(1)
    # Match action to apply when the input number is within one of the ranges.
    on_match: "MatcherOnMatch" = betterproto.message_field(2)
