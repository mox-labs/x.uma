# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: xds/type/v3/cel.proto, xds/type/v3/range.proto, xds/type/v3/typed_struct.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import Optional

import betterproto

from .cel import expr
from .google import protobuf
from .google.api.expr import v1alpha1


@dataclass
class CelExpression(betterproto.Message):
    """
    Either parsed or checked representation of the `Common Expression Language
    <https://github.com/google/cel-spec>`_ (CEL) program.
    """

    # Parsed expression in abstract syntax tree (AST) form. Deprecated -- use
    # ``cel_expr_parsed`` field instead. If ``cel_expr_parsed`` or
    # ``cel_expr_checked`` is set, this field is not used.
    parsed_expr: v1alpha1.ParsedExpr = betterproto.message_field(
        1, group="expr_specifier"
    )
    # Parsed expression in abstract syntax tree (AST) form that has been
    # successfully type checked. Deprecated -- use ``cel_expr_checked`` field
    # instead. If ``cel_expr_parsed`` or ``cel_expr_checked`` is set, this field
    # is not used.
    checked_expr: v1alpha1.CheckedExpr = betterproto.message_field(
        2, group="expr_specifier"
    )
    # Parsed expression in abstract syntax tree (AST) form. If
    # ``cel_expr_checked`` is set, this field is not used.
    cel_expr_parsed: expr.ParsedExpr = betterproto.message_field(3)
    # Parsed expression in abstract syntax tree (AST) form that has been
    # successfully type checked. If set, takes precedence over
    # ``cel_expr_parsed``.
    cel_expr_checked: expr.CheckedExpr = betterproto.message_field(4)
    # Unparsed expression in string form. For example, ``request.headers['x-env']
    # == 'prod'`` will get ``x-env`` header value and compare it with ``prod``.
    # Check the `Common Expression Language <https://github.com/google/cel-
    # spec>`_ for more details. If set, takes precedence over ``cel_expr_parsed``
    # and ``cel_expr_checked``.
    cel_expr_string: str = betterproto.string_field(5)


@dataclass
class CelExtractString(betterproto.Message):
    """
    Extracts a string by evaluating a `Common Expression Language
    <https://github.com/google/cel-spec>`_ (CEL) expression against the
    standardized set of :ref:`HTTP attributes <arch_overview_attributes>`. ..
    attention::   Besides CEL evaluation raising an error explicitly, CEL
    program returning a type other than   the ``string``, or not returning
    anything, are considered an error as well. [#comment:TODO(sergiitk): When
    implemented, add the extension tag.]
    """

    # The CEL expression used to extract a string from the CEL environment. the
    # "subject string") that should be replaced.
    expr_extract: "CelExpression" = betterproto.message_field(1)
    # If CEL expression evaluates to an error, this value is be returned to the
    # caller. If not set, the error is propagated to the caller.
    default_value: Optional[str] = betterproto.message_field(
        2, wraps=betterproto.TYPE_STRING
    )


@dataclass
class Int64Range(betterproto.Message):
    """
    Specifies the int64 start and end of the range using half-open interval
    semantics [start, end).
    """

    # start of the range (inclusive)
    start: int = betterproto.int64_field(1)
    # end of the range (exclusive)
    end: int = betterproto.int64_field(2)


@dataclass
class Int32Range(betterproto.Message):
    """
    Specifies the int32 start and end of the range using half-open interval
    semantics [start, end).
    """

    # start of the range (inclusive)
    start: int = betterproto.int32_field(1)
    # end of the range (exclusive)
    end: int = betterproto.int32_field(2)


@dataclass
class DoubleRange(betterproto.Message):
    """
    Specifies the double start and end of the range using half-open interval
    semantics [start, end).
    """

    # start of the range (inclusive)
    start: float = betterproto.double_field(1)
    # end of the range (exclusive)
    end: float = betterproto.double_field(2)


@dataclass
class TypedStruct(betterproto.Message):
    """
    A TypedStruct contains an arbitrary JSON serialized protocol buffer message
    with a URL that describes the type of the serialized message. This is very
    similar to google.protobuf.Any, instead of having protocol buffer binary,
    this employs google.protobuf.Struct as value. This message is intended to
    be embedded inside Any, so it shouldn't be directly referred from other
    UDPA messages. When packing an opaque extension config, packing the
    expected type into Any is preferred wherever possible for its efficiency.
    TypedStruct should be used only if a proto descriptor is not available, for
    example if: - A control plane sends opaque message that is originally from
    external source in human readable   format such as JSON or YAML. - The
    control plane doesn't have the knowledge of the protocol buffer schema
    hence it cannot   serialize the message in protocol buffer binary format. -
    The DPLB doesn't have have the knowledge of the protocol buffer schema its
    plugin or extension   uses. This has to be indicated in the DPLB capability
    negotiation. When a DPLB receives a TypedStruct in Any, it should: - Check
    if the type_url of the TypedStruct matches the type the extension expects.
    - Convert value to the type described in type_url and perform validation.
    TODO(lizan): Figure out how TypeStruct should be used with DPLB extensions
    that doesn't link protobuf descriptor with DPLB itself, (e.g. gRPC LB
    Plugin, Envoy WASM extensions).
    """

    # A URL that uniquely identifies the type of the serialize protocol buffer
    # message. This has same semantics and format described in
    # google.protobuf.Any: https://github.com/protocolbuffers/protobuf/blob/maste
    # r/src/google/protobuf/any.proto
    type_url: str = betterproto.string_field(1)
    # A JSON representation of the above specified type.
    value: protobuf.Struct = betterproto.message_field(2)
