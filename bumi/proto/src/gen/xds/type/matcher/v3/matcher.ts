// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               unknown
// source: xds/type/matcher/v3/matcher.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { TypedExtensionConfig } from "../../../core/v3/extension";
import { StringMatcher } from "./string";

export const protobufPackage = "xds.type.matcher.v3";

/**
 * A matcher, which may traverse a matching tree in order to result in a match action.
 * During matching, the tree will be traversed until a match is found, or if no match
 * is found the action specified by the most specific on_no_match will be evaluated.
 * As an on_no_match might result in another matching tree being evaluated, this process
 * might repeat several times until the final OnMatch (or no match) is decided.
 */
export interface Matcher {
  /** A linear list of matchers to evaluate. */
  matcherList?:
    | Matcher_MatcherList
    | undefined;
  /** A match tree to evaluate. */
  matcherTree?:
    | Matcher_MatcherTree
    | undefined;
  /**
   * Optional OnMatch to use if no matcher above matched (e.g., if there are no matchers specified
   * above, or if none of the matches specified above succeeded).
   * If no matcher above matched and this field is not populated, the match will be considered unsuccessful.
   */
  onNoMatch: Matcher_OnMatch | undefined;
}

/** What to do if a match is successful. */
export interface Matcher_OnMatch {
  /**
   * Nested matcher to evaluate.
   * If the nested matcher does not match and does not specify
   * on_no_match, then this matcher is considered not to have
   * matched, even if a predicate at this level or above returned
   * true.
   */
  matcher?:
    | Matcher
    | undefined;
  /** Protocol-specific action to take. */
  action?:
    | TypedExtensionConfig
    | undefined;
  /**
   * If true and the Matcher matches, the action will be taken but the caller
   * will behave as if the Matcher did not match. A subsequent matcher or
   * on_no_match action will be used instead.
   * This field is not supported in all contexts in which the matcher API is
   * used. If this field is set in a context in which it's not supported,
   * the resource will be rejected.
   */
  keepMatching: boolean;
}

/**
 * A linear list of field matchers.
 * The field matchers are evaluated in order, and the first match
 * wins.
 */
export interface Matcher_MatcherList {
  /** A list of matchers. First match wins. */
  matchers: Matcher_MatcherList_FieldMatcher[];
}

/** Predicate to determine if a match is successful. */
export interface Matcher_MatcherList_Predicate {
  /** A single predicate to evaluate. */
  singlePredicate?:
    | Matcher_MatcherList_Predicate_SinglePredicate
    | undefined;
  /** A list of predicates to be OR-ed together. */
  orMatcher?:
    | Matcher_MatcherList_Predicate_PredicateList
    | undefined;
  /** A list of predicates to be AND-ed together. */
  andMatcher?:
    | Matcher_MatcherList_Predicate_PredicateList
    | undefined;
  /** The invert of a predicate */
  notMatcher?: Matcher_MatcherList_Predicate | undefined;
}

/** Predicate for a single input field. */
export interface Matcher_MatcherList_Predicate_SinglePredicate {
  /**
   * Protocol-specific specification of input field to match on.
   * [#extension-category: envoy.matching.common_inputs]
   */
  input:
    | TypedExtensionConfig
    | undefined;
  /** Built-in string matcher. */
  valueMatch?:
    | StringMatcher
    | undefined;
  /**
   * Extension for custom matching logic.
   * [#extension-category: envoy.matching.input_matchers]
   */
  customMatch?: TypedExtensionConfig | undefined;
}

/** A list of two or more matchers. Used to allow using a list within a oneof. */
export interface Matcher_MatcherList_Predicate_PredicateList {
  predicate: Matcher_MatcherList_Predicate[];
}

/** An individual matcher. */
export interface Matcher_MatcherList_FieldMatcher {
  /** Determines if the match succeeds. */
  predicate:
    | Matcher_MatcherList_Predicate
    | undefined;
  /** What to do if the match succeeds. */
  onMatch: Matcher_OnMatch | undefined;
}

export interface Matcher_MatcherTree {
  /** Protocol-specific specification of input field to match on. */
  input: TypedExtensionConfig | undefined;
  exactMatchMap?:
    | Matcher_MatcherTree_MatchMap
    | undefined;
  /** Longest matching prefix wins. */
  prefixMatchMap?:
    | Matcher_MatcherTree_MatchMap
    | undefined;
  /** Extension for custom matching logic. */
  customMatch?: TypedExtensionConfig | undefined;
}

/** A map of configured matchers. Used to allow using a map within a oneof. */
export interface Matcher_MatcherTree_MatchMap {
  map: { [key: string]: Matcher_OnMatch };
}

export interface Matcher_MatcherTree_MatchMap_MapEntry {
  key: string;
  value: Matcher_OnMatch | undefined;
}

function createBaseMatcher(): Matcher {
  return { matcherList: undefined, matcherTree: undefined, onNoMatch: undefined };
}

export const Matcher: MessageFns<Matcher> = {
  encode(message: Matcher, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.matcherList !== undefined) {
      Matcher_MatcherList.encode(message.matcherList, writer.uint32(10).fork()).join();
    }
    if (message.matcherTree !== undefined) {
      Matcher_MatcherTree.encode(message.matcherTree, writer.uint32(18).fork()).join();
    }
    if (message.onNoMatch !== undefined) {
      Matcher_OnMatch.encode(message.onNoMatch, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Matcher {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatcher();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.matcherList = Matcher_MatcherList.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.matcherTree = Matcher_MatcherTree.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.onNoMatch = Matcher_OnMatch.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Matcher {
    return {
      matcherList: isSet(object.matcherList)
        ? Matcher_MatcherList.fromJSON(object.matcherList)
        : isSet(object.matcher_list)
        ? Matcher_MatcherList.fromJSON(object.matcher_list)
        : undefined,
      matcherTree: isSet(object.matcherTree)
        ? Matcher_MatcherTree.fromJSON(object.matcherTree)
        : isSet(object.matcher_tree)
        ? Matcher_MatcherTree.fromJSON(object.matcher_tree)
        : undefined,
      onNoMatch: isSet(object.onNoMatch)
        ? Matcher_OnMatch.fromJSON(object.onNoMatch)
        : isSet(object.on_no_match)
        ? Matcher_OnMatch.fromJSON(object.on_no_match)
        : undefined,
    };
  },

  toJSON(message: Matcher): unknown {
    const obj: any = {};
    if (message.matcherList !== undefined) {
      obj.matcherList = Matcher_MatcherList.toJSON(message.matcherList);
    }
    if (message.matcherTree !== undefined) {
      obj.matcherTree = Matcher_MatcherTree.toJSON(message.matcherTree);
    }
    if (message.onNoMatch !== undefined) {
      obj.onNoMatch = Matcher_OnMatch.toJSON(message.onNoMatch);
    }
    return obj;
  },

  create(base?: DeepPartial<Matcher>): Matcher {
    return Matcher.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Matcher>): Matcher {
    const message = createBaseMatcher();
    message.matcherList = (object.matcherList !== undefined && object.matcherList !== null)
      ? Matcher_MatcherList.fromPartial(object.matcherList)
      : undefined;
    message.matcherTree = (object.matcherTree !== undefined && object.matcherTree !== null)
      ? Matcher_MatcherTree.fromPartial(object.matcherTree)
      : undefined;
    message.onNoMatch = (object.onNoMatch !== undefined && object.onNoMatch !== null)
      ? Matcher_OnMatch.fromPartial(object.onNoMatch)
      : undefined;
    return message;
  },
};

function createBaseMatcher_OnMatch(): Matcher_OnMatch {
  return { matcher: undefined, action: undefined, keepMatching: false };
}

export const Matcher_OnMatch: MessageFns<Matcher_OnMatch> = {
  encode(message: Matcher_OnMatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.matcher !== undefined) {
      Matcher.encode(message.matcher, writer.uint32(10).fork()).join();
    }
    if (message.action !== undefined) {
      TypedExtensionConfig.encode(message.action, writer.uint32(18).fork()).join();
    }
    if (message.keepMatching !== false) {
      writer.uint32(24).bool(message.keepMatching);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Matcher_OnMatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatcher_OnMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.matcher = Matcher.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.action = TypedExtensionConfig.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.keepMatching = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Matcher_OnMatch {
    return {
      matcher: isSet(object.matcher) ? Matcher.fromJSON(object.matcher) : undefined,
      action: isSet(object.action) ? TypedExtensionConfig.fromJSON(object.action) : undefined,
      keepMatching: isSet(object.keepMatching)
        ? globalThis.Boolean(object.keepMatching)
        : isSet(object.keep_matching)
        ? globalThis.Boolean(object.keep_matching)
        : false,
    };
  },

  toJSON(message: Matcher_OnMatch): unknown {
    const obj: any = {};
    if (message.matcher !== undefined) {
      obj.matcher = Matcher.toJSON(message.matcher);
    }
    if (message.action !== undefined) {
      obj.action = TypedExtensionConfig.toJSON(message.action);
    }
    if (message.keepMatching !== false) {
      obj.keepMatching = message.keepMatching;
    }
    return obj;
  },

  create(base?: DeepPartial<Matcher_OnMatch>): Matcher_OnMatch {
    return Matcher_OnMatch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Matcher_OnMatch>): Matcher_OnMatch {
    const message = createBaseMatcher_OnMatch();
    message.matcher = (object.matcher !== undefined && object.matcher !== null)
      ? Matcher.fromPartial(object.matcher)
      : undefined;
    message.action = (object.action !== undefined && object.action !== null)
      ? TypedExtensionConfig.fromPartial(object.action)
      : undefined;
    message.keepMatching = object.keepMatching ?? false;
    return message;
  },
};

function createBaseMatcher_MatcherList(): Matcher_MatcherList {
  return { matchers: [] };
}

export const Matcher_MatcherList: MessageFns<Matcher_MatcherList> = {
  encode(message: Matcher_MatcherList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.matchers) {
      Matcher_MatcherList_FieldMatcher.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Matcher_MatcherList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatcher_MatcherList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.matchers.push(Matcher_MatcherList_FieldMatcher.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Matcher_MatcherList {
    return {
      matchers: globalThis.Array.isArray(object?.matchers)
        ? object.matchers.map((e: any) => Matcher_MatcherList_FieldMatcher.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Matcher_MatcherList): unknown {
    const obj: any = {};
    if (message.matchers?.length) {
      obj.matchers = message.matchers.map((e) => Matcher_MatcherList_FieldMatcher.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Matcher_MatcherList>): Matcher_MatcherList {
    return Matcher_MatcherList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Matcher_MatcherList>): Matcher_MatcherList {
    const message = createBaseMatcher_MatcherList();
    message.matchers = object.matchers?.map((e) => Matcher_MatcherList_FieldMatcher.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMatcher_MatcherList_Predicate(): Matcher_MatcherList_Predicate {
  return { singlePredicate: undefined, orMatcher: undefined, andMatcher: undefined, notMatcher: undefined };
}

export const Matcher_MatcherList_Predicate: MessageFns<Matcher_MatcherList_Predicate> = {
  encode(message: Matcher_MatcherList_Predicate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.singlePredicate !== undefined) {
      Matcher_MatcherList_Predicate_SinglePredicate.encode(message.singlePredicate, writer.uint32(10).fork()).join();
    }
    if (message.orMatcher !== undefined) {
      Matcher_MatcherList_Predicate_PredicateList.encode(message.orMatcher, writer.uint32(18).fork()).join();
    }
    if (message.andMatcher !== undefined) {
      Matcher_MatcherList_Predicate_PredicateList.encode(message.andMatcher, writer.uint32(26).fork()).join();
    }
    if (message.notMatcher !== undefined) {
      Matcher_MatcherList_Predicate.encode(message.notMatcher, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Matcher_MatcherList_Predicate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatcher_MatcherList_Predicate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.singlePredicate = Matcher_MatcherList_Predicate_SinglePredicate.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.orMatcher = Matcher_MatcherList_Predicate_PredicateList.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.andMatcher = Matcher_MatcherList_Predicate_PredicateList.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.notMatcher = Matcher_MatcherList_Predicate.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Matcher_MatcherList_Predicate {
    return {
      singlePredicate: isSet(object.singlePredicate)
        ? Matcher_MatcherList_Predicate_SinglePredicate.fromJSON(object.singlePredicate)
        : isSet(object.single_predicate)
        ? Matcher_MatcherList_Predicate_SinglePredicate.fromJSON(object.single_predicate)
        : undefined,
      orMatcher: isSet(object.orMatcher)
        ? Matcher_MatcherList_Predicate_PredicateList.fromJSON(object.orMatcher)
        : isSet(object.or_matcher)
        ? Matcher_MatcherList_Predicate_PredicateList.fromJSON(object.or_matcher)
        : undefined,
      andMatcher: isSet(object.andMatcher)
        ? Matcher_MatcherList_Predicate_PredicateList.fromJSON(object.andMatcher)
        : isSet(object.and_matcher)
        ? Matcher_MatcherList_Predicate_PredicateList.fromJSON(object.and_matcher)
        : undefined,
      notMatcher: isSet(object.notMatcher)
        ? Matcher_MatcherList_Predicate.fromJSON(object.notMatcher)
        : isSet(object.not_matcher)
        ? Matcher_MatcherList_Predicate.fromJSON(object.not_matcher)
        : undefined,
    };
  },

  toJSON(message: Matcher_MatcherList_Predicate): unknown {
    const obj: any = {};
    if (message.singlePredicate !== undefined) {
      obj.singlePredicate = Matcher_MatcherList_Predicate_SinglePredicate.toJSON(message.singlePredicate);
    }
    if (message.orMatcher !== undefined) {
      obj.orMatcher = Matcher_MatcherList_Predicate_PredicateList.toJSON(message.orMatcher);
    }
    if (message.andMatcher !== undefined) {
      obj.andMatcher = Matcher_MatcherList_Predicate_PredicateList.toJSON(message.andMatcher);
    }
    if (message.notMatcher !== undefined) {
      obj.notMatcher = Matcher_MatcherList_Predicate.toJSON(message.notMatcher);
    }
    return obj;
  },

  create(base?: DeepPartial<Matcher_MatcherList_Predicate>): Matcher_MatcherList_Predicate {
    return Matcher_MatcherList_Predicate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Matcher_MatcherList_Predicate>): Matcher_MatcherList_Predicate {
    const message = createBaseMatcher_MatcherList_Predicate();
    message.singlePredicate = (object.singlePredicate !== undefined && object.singlePredicate !== null)
      ? Matcher_MatcherList_Predicate_SinglePredicate.fromPartial(object.singlePredicate)
      : undefined;
    message.orMatcher = (object.orMatcher !== undefined && object.orMatcher !== null)
      ? Matcher_MatcherList_Predicate_PredicateList.fromPartial(object.orMatcher)
      : undefined;
    message.andMatcher = (object.andMatcher !== undefined && object.andMatcher !== null)
      ? Matcher_MatcherList_Predicate_PredicateList.fromPartial(object.andMatcher)
      : undefined;
    message.notMatcher = (object.notMatcher !== undefined && object.notMatcher !== null)
      ? Matcher_MatcherList_Predicate.fromPartial(object.notMatcher)
      : undefined;
    return message;
  },
};

function createBaseMatcher_MatcherList_Predicate_SinglePredicate(): Matcher_MatcherList_Predicate_SinglePredicate {
  return { input: undefined, valueMatch: undefined, customMatch: undefined };
}

export const Matcher_MatcherList_Predicate_SinglePredicate: MessageFns<Matcher_MatcherList_Predicate_SinglePredicate> =
  {
    encode(
      message: Matcher_MatcherList_Predicate_SinglePredicate,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.input !== undefined) {
        TypedExtensionConfig.encode(message.input, writer.uint32(10).fork()).join();
      }
      if (message.valueMatch !== undefined) {
        StringMatcher.encode(message.valueMatch, writer.uint32(18).fork()).join();
      }
      if (message.customMatch !== undefined) {
        TypedExtensionConfig.encode(message.customMatch, writer.uint32(26).fork()).join();
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): Matcher_MatcherList_Predicate_SinglePredicate {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseMatcher_MatcherList_Predicate_SinglePredicate();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.input = TypedExtensionConfig.decode(reader, reader.uint32());
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.valueMatch = StringMatcher.decode(reader, reader.uint32());
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            message.customMatch = TypedExtensionConfig.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): Matcher_MatcherList_Predicate_SinglePredicate {
      return {
        input: isSet(object.input) ? TypedExtensionConfig.fromJSON(object.input) : undefined,
        valueMatch: isSet(object.valueMatch)
          ? StringMatcher.fromJSON(object.valueMatch)
          : isSet(object.value_match)
          ? StringMatcher.fromJSON(object.value_match)
          : undefined,
        customMatch: isSet(object.customMatch)
          ? TypedExtensionConfig.fromJSON(object.customMatch)
          : isSet(object.custom_match)
          ? TypedExtensionConfig.fromJSON(object.custom_match)
          : undefined,
      };
    },

    toJSON(message: Matcher_MatcherList_Predicate_SinglePredicate): unknown {
      const obj: any = {};
      if (message.input !== undefined) {
        obj.input = TypedExtensionConfig.toJSON(message.input);
      }
      if (message.valueMatch !== undefined) {
        obj.valueMatch = StringMatcher.toJSON(message.valueMatch);
      }
      if (message.customMatch !== undefined) {
        obj.customMatch = TypedExtensionConfig.toJSON(message.customMatch);
      }
      return obj;
    },

    create(
      base?: DeepPartial<Matcher_MatcherList_Predicate_SinglePredicate>,
    ): Matcher_MatcherList_Predicate_SinglePredicate {
      return Matcher_MatcherList_Predicate_SinglePredicate.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<Matcher_MatcherList_Predicate_SinglePredicate>,
    ): Matcher_MatcherList_Predicate_SinglePredicate {
      const message = createBaseMatcher_MatcherList_Predicate_SinglePredicate();
      message.input = (object.input !== undefined && object.input !== null)
        ? TypedExtensionConfig.fromPartial(object.input)
        : undefined;
      message.valueMatch = (object.valueMatch !== undefined && object.valueMatch !== null)
        ? StringMatcher.fromPartial(object.valueMatch)
        : undefined;
      message.customMatch = (object.customMatch !== undefined && object.customMatch !== null)
        ? TypedExtensionConfig.fromPartial(object.customMatch)
        : undefined;
      return message;
    },
  };

function createBaseMatcher_MatcherList_Predicate_PredicateList(): Matcher_MatcherList_Predicate_PredicateList {
  return { predicate: [] };
}

export const Matcher_MatcherList_Predicate_PredicateList: MessageFns<Matcher_MatcherList_Predicate_PredicateList> = {
  encode(
    message: Matcher_MatcherList_Predicate_PredicateList,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.predicate) {
      Matcher_MatcherList_Predicate.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Matcher_MatcherList_Predicate_PredicateList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatcher_MatcherList_Predicate_PredicateList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.predicate.push(Matcher_MatcherList_Predicate.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Matcher_MatcherList_Predicate_PredicateList {
    return {
      predicate: globalThis.Array.isArray(object?.predicate)
        ? object.predicate.map((e: any) => Matcher_MatcherList_Predicate.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Matcher_MatcherList_Predicate_PredicateList): unknown {
    const obj: any = {};
    if (message.predicate?.length) {
      obj.predicate = message.predicate.map((e) => Matcher_MatcherList_Predicate.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Matcher_MatcherList_Predicate_PredicateList>): Matcher_MatcherList_Predicate_PredicateList {
    return Matcher_MatcherList_Predicate_PredicateList.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<Matcher_MatcherList_Predicate_PredicateList>,
  ): Matcher_MatcherList_Predicate_PredicateList {
    const message = createBaseMatcher_MatcherList_Predicate_PredicateList();
    message.predicate = object.predicate?.map((e) => Matcher_MatcherList_Predicate.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMatcher_MatcherList_FieldMatcher(): Matcher_MatcherList_FieldMatcher {
  return { predicate: undefined, onMatch: undefined };
}

export const Matcher_MatcherList_FieldMatcher: MessageFns<Matcher_MatcherList_FieldMatcher> = {
  encode(message: Matcher_MatcherList_FieldMatcher, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.predicate !== undefined) {
      Matcher_MatcherList_Predicate.encode(message.predicate, writer.uint32(10).fork()).join();
    }
    if (message.onMatch !== undefined) {
      Matcher_OnMatch.encode(message.onMatch, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Matcher_MatcherList_FieldMatcher {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatcher_MatcherList_FieldMatcher();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.predicate = Matcher_MatcherList_Predicate.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.onMatch = Matcher_OnMatch.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Matcher_MatcherList_FieldMatcher {
    return {
      predicate: isSet(object.predicate) ? Matcher_MatcherList_Predicate.fromJSON(object.predicate) : undefined,
      onMatch: isSet(object.onMatch)
        ? Matcher_OnMatch.fromJSON(object.onMatch)
        : isSet(object.on_match)
        ? Matcher_OnMatch.fromJSON(object.on_match)
        : undefined,
    };
  },

  toJSON(message: Matcher_MatcherList_FieldMatcher): unknown {
    const obj: any = {};
    if (message.predicate !== undefined) {
      obj.predicate = Matcher_MatcherList_Predicate.toJSON(message.predicate);
    }
    if (message.onMatch !== undefined) {
      obj.onMatch = Matcher_OnMatch.toJSON(message.onMatch);
    }
    return obj;
  },

  create(base?: DeepPartial<Matcher_MatcherList_FieldMatcher>): Matcher_MatcherList_FieldMatcher {
    return Matcher_MatcherList_FieldMatcher.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Matcher_MatcherList_FieldMatcher>): Matcher_MatcherList_FieldMatcher {
    const message = createBaseMatcher_MatcherList_FieldMatcher();
    message.predicate = (object.predicate !== undefined && object.predicate !== null)
      ? Matcher_MatcherList_Predicate.fromPartial(object.predicate)
      : undefined;
    message.onMatch = (object.onMatch !== undefined && object.onMatch !== null)
      ? Matcher_OnMatch.fromPartial(object.onMatch)
      : undefined;
    return message;
  },
};

function createBaseMatcher_MatcherTree(): Matcher_MatcherTree {
  return { input: undefined, exactMatchMap: undefined, prefixMatchMap: undefined, customMatch: undefined };
}

export const Matcher_MatcherTree: MessageFns<Matcher_MatcherTree> = {
  encode(message: Matcher_MatcherTree, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.input !== undefined) {
      TypedExtensionConfig.encode(message.input, writer.uint32(10).fork()).join();
    }
    if (message.exactMatchMap !== undefined) {
      Matcher_MatcherTree_MatchMap.encode(message.exactMatchMap, writer.uint32(18).fork()).join();
    }
    if (message.prefixMatchMap !== undefined) {
      Matcher_MatcherTree_MatchMap.encode(message.prefixMatchMap, writer.uint32(26).fork()).join();
    }
    if (message.customMatch !== undefined) {
      TypedExtensionConfig.encode(message.customMatch, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Matcher_MatcherTree {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatcher_MatcherTree();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.input = TypedExtensionConfig.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.exactMatchMap = Matcher_MatcherTree_MatchMap.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.prefixMatchMap = Matcher_MatcherTree_MatchMap.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.customMatch = TypedExtensionConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Matcher_MatcherTree {
    return {
      input: isSet(object.input) ? TypedExtensionConfig.fromJSON(object.input) : undefined,
      exactMatchMap: isSet(object.exactMatchMap)
        ? Matcher_MatcherTree_MatchMap.fromJSON(object.exactMatchMap)
        : isSet(object.exact_match_map)
        ? Matcher_MatcherTree_MatchMap.fromJSON(object.exact_match_map)
        : undefined,
      prefixMatchMap: isSet(object.prefixMatchMap)
        ? Matcher_MatcherTree_MatchMap.fromJSON(object.prefixMatchMap)
        : isSet(object.prefix_match_map)
        ? Matcher_MatcherTree_MatchMap.fromJSON(object.prefix_match_map)
        : undefined,
      customMatch: isSet(object.customMatch)
        ? TypedExtensionConfig.fromJSON(object.customMatch)
        : isSet(object.custom_match)
        ? TypedExtensionConfig.fromJSON(object.custom_match)
        : undefined,
    };
  },

  toJSON(message: Matcher_MatcherTree): unknown {
    const obj: any = {};
    if (message.input !== undefined) {
      obj.input = TypedExtensionConfig.toJSON(message.input);
    }
    if (message.exactMatchMap !== undefined) {
      obj.exactMatchMap = Matcher_MatcherTree_MatchMap.toJSON(message.exactMatchMap);
    }
    if (message.prefixMatchMap !== undefined) {
      obj.prefixMatchMap = Matcher_MatcherTree_MatchMap.toJSON(message.prefixMatchMap);
    }
    if (message.customMatch !== undefined) {
      obj.customMatch = TypedExtensionConfig.toJSON(message.customMatch);
    }
    return obj;
  },

  create(base?: DeepPartial<Matcher_MatcherTree>): Matcher_MatcherTree {
    return Matcher_MatcherTree.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Matcher_MatcherTree>): Matcher_MatcherTree {
    const message = createBaseMatcher_MatcherTree();
    message.input = (object.input !== undefined && object.input !== null)
      ? TypedExtensionConfig.fromPartial(object.input)
      : undefined;
    message.exactMatchMap = (object.exactMatchMap !== undefined && object.exactMatchMap !== null)
      ? Matcher_MatcherTree_MatchMap.fromPartial(object.exactMatchMap)
      : undefined;
    message.prefixMatchMap = (object.prefixMatchMap !== undefined && object.prefixMatchMap !== null)
      ? Matcher_MatcherTree_MatchMap.fromPartial(object.prefixMatchMap)
      : undefined;
    message.customMatch = (object.customMatch !== undefined && object.customMatch !== null)
      ? TypedExtensionConfig.fromPartial(object.customMatch)
      : undefined;
    return message;
  },
};

function createBaseMatcher_MatcherTree_MatchMap(): Matcher_MatcherTree_MatchMap {
  return { map: {} };
}

export const Matcher_MatcherTree_MatchMap: MessageFns<Matcher_MatcherTree_MatchMap> = {
  encode(message: Matcher_MatcherTree_MatchMap, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    globalThis.Object.entries(message.map).forEach(([key, value]: [string, Matcher_OnMatch]) => {
      Matcher_MatcherTree_MatchMap_MapEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Matcher_MatcherTree_MatchMap {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatcher_MatcherTree_MatchMap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = Matcher_MatcherTree_MatchMap_MapEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.map[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Matcher_MatcherTree_MatchMap {
    return {
      map: isObject(object.map)
        ? (globalThis.Object.entries(object.map) as [string, any][]).reduce(
          (acc: { [key: string]: Matcher_OnMatch }, [key, value]: [string, any]) => {
            acc[key] = Matcher_OnMatch.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: Matcher_MatcherTree_MatchMap): unknown {
    const obj: any = {};
    if (message.map) {
      const entries = globalThis.Object.entries(message.map) as [string, Matcher_OnMatch][];
      if (entries.length > 0) {
        obj.map = {};
        entries.forEach(([k, v]) => {
          obj.map[k] = Matcher_OnMatch.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<Matcher_MatcherTree_MatchMap>): Matcher_MatcherTree_MatchMap {
    return Matcher_MatcherTree_MatchMap.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Matcher_MatcherTree_MatchMap>): Matcher_MatcherTree_MatchMap {
    const message = createBaseMatcher_MatcherTree_MatchMap();
    message.map = (globalThis.Object.entries(object.map ?? {}) as [string, Matcher_OnMatch][]).reduce(
      (acc: { [key: string]: Matcher_OnMatch }, [key, value]: [string, Matcher_OnMatch]) => {
        if (value !== undefined) {
          acc[key] = Matcher_OnMatch.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseMatcher_MatcherTree_MatchMap_MapEntry(): Matcher_MatcherTree_MatchMap_MapEntry {
  return { key: "", value: undefined };
}

export const Matcher_MatcherTree_MatchMap_MapEntry: MessageFns<Matcher_MatcherTree_MatchMap_MapEntry> = {
  encode(message: Matcher_MatcherTree_MatchMap_MapEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Matcher_OnMatch.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Matcher_MatcherTree_MatchMap_MapEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatcher_MatcherTree_MatchMap_MapEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Matcher_OnMatch.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Matcher_MatcherTree_MatchMap_MapEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Matcher_OnMatch.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Matcher_MatcherTree_MatchMap_MapEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Matcher_OnMatch.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<Matcher_MatcherTree_MatchMap_MapEntry>): Matcher_MatcherTree_MatchMap_MapEntry {
    return Matcher_MatcherTree_MatchMap_MapEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Matcher_MatcherTree_MatchMap_MapEntry>): Matcher_MatcherTree_MatchMap_MapEntry {
    const message = createBaseMatcher_MatcherTree_MatchMap_MapEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Matcher_OnMatch.fromPartial(object.value)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
